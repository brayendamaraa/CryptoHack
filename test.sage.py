

# This file was *autogenerated* from the file test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_50 = Integer(50); _sage_const_31337 = Integer(31337); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_12 = Integer(12)
from random import randint

P = _sage_const_2 
N = _sage_const_50 
E = _sage_const_31337 

FLAG = b'crypto{FLAG_PLACEHOLDER}'

def bytes_to_binary(s):
    bin_str = ''.join(format(b, '08b') for b in s)
    bits = [int(c) for c in bin_str]
    return bits

def generate_mat():
    while True:
        msg = bytes_to_binary(FLAG)
        msg += [randint(_sage_const_0 , _sage_const_1 ) for _ in range(N*N - len(msg))]

        rows = [msg[i::N] for i in range(N)]
        mat = Matrix(GF(_sage_const_2 ), rows)

        if mat.determinant() != _sage_const_0  and mat.multiplicative_order() > _sage_const_10 **_sage_const_12 :
            return mat


mat = generate_mat()

def matrix_to_key(M):
    return tuple(tuple(row) for row in M.rows())

def dlp_bsgs_matrix(A, B, order_bound):
    from math import ceil, sqrt
    F = A.base_ring()
    n = A.nrows()
    m = ceil(sqrt(order_bound))

    # Precompute baby steps
    baby_steps = {}
    Aj = identity_matrix(F, n)
    for j in range(m):
        baby_steps[matrix_to_key(Aj)] = j
        Aj = Aj * A

    # Precompute A^{-m}
    Ainv = A.inverse()
    Ainv_m = Ainv**m

    # Giant steps
    gamma = B
    for i in range(m):
        key = matrix_to_key(gamma)
        if key in baby_steps:
            j = baby_steps[key]
            return i * m + j
        gamma = Ainv_m * gamma

    return None

dlp_bsgs_matrix(mat, mat**E, mat.multiplicative_order())

